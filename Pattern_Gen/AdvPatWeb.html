<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ADVPATWEB - AI-Confusing Adversarial Pattern Generator</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f4f4f4; margin: 20px; }
        canvas { border: 1px solid #ccc; margin: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        select, input[type="checkbox"], input[type="range"], input[type="number"] { margin: 10px; font-size: 16px; }
        label { display: block; margin: 5px; }
        .container { max-width: 1300px; margin: auto; }
        #colorCanvas, #bwCanvas { display: inline-block; }
        #infoPanel { margin: 20px; padding: 15px; background-color: #fff; border: 1px solid #ddd; border-radius: 5px; text-align: left; max-width: 800px; margin: auto; }
        #patternDescription { font-style: italic; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ADVPAT IR-Wear AI-Confusing Pattern Generator</h1>
        <p>This web application generates unique, printable patterns designed to confuse computer vision (CV) and AI systems, tailored for the IR-Wear Project. It integrates optical illusions, adversarial patches, fractal designs, and hybrid layering techniques to create privacy-enhancing patterns for clothing and accessories. Patterns can disrupt facial recognition, object detection, and surveillance AI in both visible and simulated IR contexts. Customize, combine, layer, and export for DIY printing on garments to complement IR LED integrations.</p>
        <p>Features include: pattern selection with descriptions, multi-layer combining with opacity and composite mode controls, canvas size adjustment for print formats (e.g., A4 for fabric tiling), complexity sliders for illusions/fractals, color palette themes (including high-contrast for dazzle or subtle noise for adversarial), random seed for reproducibility, tiling preview for repeating fabric designs, SVG export for vector printing, PNG export, direct print support, and info panel with pattern explanations tied to privacy applications.</p>
        
        <label for="patternSelect">Select Primary Pattern Type:</label>
        <select id="patternSelect">
            <option value="random">Random</option>
            <option value="lines">Random Lines (Disrupts edge detection in CV)</option>
            <option value="circles">Circles (Creates false features for object recognition)</option>
            <option value="noise">Noise (Adversarial perturbations to fool classifiers)</option>
            <option value="grid">Distorted Grid (Mimics invisibility sweater patterns)</option>
            <option value="moire">Moire Concentric (Induces illusory motion in AI)</option>
            <option value="dazzle">CV Dazzle (Asymmetrical blocks for facial evasion)</option>
            <option value="adversarial">Adversarial Patch (High-frequency noise for misclassification)</option>
            <option value="snake">Rotating Snake (Peripheral drift illusion for AI)</option>
            <option value="invisibility">Invisibility Grid (Brightness perturbations for detection suppression)</option>
            <option value="penrose">Penrose Triangle (Impossible object to confuse 3D perception)</option>
            <option value="zebra">Zebra Stripes (Motion confusion for tracking AI)</option>
            <option value="muller">Müller-Lyer (Size/angle distortion for scale errors)</option>
            <option value="checker">Checker Shadow (Color constancy illusion for lighting misinterpretation)</option>
            <option value="stairs">3D Impossible Stairs (Depth perception fooling using Three.js)</option>
            <option value="fraser">Fraser Spiral (Spiral illusion for orientation errors)</option>
            <option value="mandelbrot">Mandelbrot Fractal (Self-similar complexity for anomaly detection overload)</option>
            <option value="julia">Julia Set Fractal (Variant fractal for diverse disruptions)</option>
            <option value="sierpinski">Sierpinski Triangle (Recursive triangle for hierarchical confusion)</option>
            <option value="koch">Koch Snowflake (Curve-based fractal for boundary detection issues)</option>
            <option value="duckrabbit">Duck-Rabbit Ambiguous Figure (Bistable illusion for classification flip-flops)</option>
            <option value="hiddenimage">Hidden Image (Embedded shapes that AI might misparse)</option>
            <option value="colorconstancy">Color Constancy (Filtered colors like 'the dress' for perceptual mismatch)</option>
            <option value="animalpatch">Animal Patch (Adversarial like Cap_able, fools into seeing animals)</option>
            <option value="psychedelic">Psychedelic Print (Glasses-style patterns for impersonation)</option>
            <option value="bloom">IR Bloom Simulation (High-contrast spots mimicking LED overload)</option>
        </select>
        
        <label><input type="checkbox" id="combineCheckbox" checked> Enable Multi-Layer Combining (2-5 layers for hybrid adversarial effects)</label>
        <label for="numLayers">Number of Layers (if combining):</label>
        <input type="number" id="numLayers" min="2" max="5" value="3">
        
        <label for="opacitySlider">Layer Opacity (0-1, average for overlays):</label>
        <input type="range" id="opacitySlider" min="0.1" max="1" step="0.1" value="0.7">
        
        <label for="compositeMode">Composite Mode for Layers:</label>
        <select id="compositeMode">
            <option value="source-over">Source Over (Standard Overlay)</option>
            <option value="multiply">Multiply (Darkens for depth)</option>
            <option value="screen">Screen (Lightens for highlights)</option>
            <option value="overlay">Overlay (Combines multiply/screen)</option>
            <option value="difference">Difference (Inverts for contrast disruption)</option>
            <option value="exclusion">Exclusion (Similar to difference, softer)</option>
        </select>
        
        <label for="complexitySlider">Pattern Complexity Level (0-1, affects density/iterations):</label>
        <input type="range" id="complexitySlider" min="0" max="1" step="0.1" value="0.5">
        
        <label for="seedInput">Random Seed (for reproducibility, 0 for random):</label>
        <input type="number" id="seedInput" value="0">
        
        <label for="colorPalette">Color Palette Theme:</label>
        <select id="colorPalette">
            <option value="random">Random Colors</option>
            <option value="highcontrast">High Contrast (For Dazzle/Privacy)</option>
            <option value="subtle">Subtle Noise (Adversarial Stealth)</option>
            <option value="earthtones">Earth Tones (Camouflage Blend)</option>
            <option value="psychedelic">Psychedelic (Facial Impersonation)</option>
            <option value="irsim">IR Simulation (Grayscale with Blooms)</option>
        </select>
        
        <label for="canvasWidth">Canvas Width (pixels, for print resolution):</label>
        <input type="number" id="canvasWidth" value="600" min="300" max="2400">
        
        <label for="canvasHeight">Canvas Height (pixels):</label>
        <input type="number" id="canvasHeight" value="450" min="300" max="2400">
        
        <label><input type="checkbox" id="tileCheckbox"> Enable Tiling Preview (Repeats pattern for fabric simulation)</label>
        <label for="tileCount">Tile Count (if tiling, e.g., 2x2):</label>
        <input type="number" id="tileCount" min="1" max="4" value="1">
        
        <br>
        <button onclick="generatePatterns()">Generate New Patterns</button>
        <button onclick="window.print()">Print Patterns</button>
        <button onclick="exportPNG('colorCanvas')">Export Color PNG</button>
        <button onclick="exportPNG('bwCanvas')">Export B&W PNG</button>
        <button onclick="exportSVG('colorCanvas')">Export Color SVG</button>
        <button onclick="exportSVG('bwCanvas')">Export B&W SVG</button>
        <button onclick="showInfo()">Show Pattern Info</button>
        
        <br>
        <canvas id="colorCanvas" width="600" height="450"></canvas>
        <canvas id="bwCanvas" width="600" height="450"></canvas>
        
        <div id="infoPanel" style="display: none;">
            <h2>Pattern Information</h2>
            <p id="patternDescription"></p>
            <p>This pattern is designed for IR-Wear integration: Print on fabric to complement LED setups, confusing visible-spectrum AI during daylight. Test with CV tools to verify evasion rates (e.g., ~50% on YOLO-like detectors per research).</p>
        </div>
    </div>
    <script>
        // Seeded random function for reproducibility
        let seed = 0;
        function seededRandom() {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        const patternDescriptions = {
            lines: "Random lines disrupt edge detection algorithms in computer vision systems, creating false contours that can mislead object trackers and facial recognizers.",
            circles: "Overlapping circles generate pseudo-objects, confusing AI into detecting non-existent shapes, useful for evading surveillance in printed clothing.",
            noise: "High-frequency noise patterns act as adversarial perturbations, causing misclassifications like panda to gibbon, ideal for subtle privacy protection.",
            grid: "Distorted grids mimic University of Maryland's invisibility sweaters, suppressing person detection by degrading bounding box accuracy.",
            moire: "Moire patterns induce illusory motion, fooling motion-tracking AI and creating visual artifacts in camera feeds.",
            dazzle: "Inspired by CV Dazzle, asymmetrical high-contrast blocks obscure facial symmetry, reducing recognition confidence below thresholds.",
            adversarial: "Universal adversarial patches with deformations and noise fool classifiers across models, evading YOLO and similar detectors.",
            snake: "Rotating snake illusion creates perceived motion in static images, confusing AI perception similar to humans on 9/12 illusion types.",
            invisibility: "Brightness and contrast perturbations suppress objectness scores, making wearers 'invisible' to detectors like in COCO-trained models.",
            penrose: "Impossible objects like Penrose triangle disrupt 3D reconstruction and depth perception in AI vision systems.",
            zebra: "Zebra-like stripes confuse motion estimation and tracking, effective against gait analysis in surveillance.",
            muller: "Müller-Lyer lines distort size and angle perception, leading to scale errors in object recognition.",
            checker: "Checker shadow illusion exploits color constancy, making AI misinterpret lighting and colors, like blue-filtered images.",
            stairs: "3D impossible stairs using Three.js fool depth and spatial reasoning in vision models.",
            fraser: "Fraser spiral creates false spiral perceptions, disrupting orientation and pattern recognition in AI.",
            mandelbrot: "Mandelbrot fractals provide self-similar complexity, overloading anomaly detection and pre-training biases.",
            julia: "Julia set fractals offer variant self-similarity, useful for hierarchical confusion in CV hierarchies.",
            sierpinski: "Sierpinski triangle recursive patterns disrupt scale-invariant features in vision models.",
            koch: "Koch snowflake curves create irregular boundaries, confusing edge and contour detectors.",
            duckrabbit: "Duck-rabbit ambiguous figures cause classification instability, mimicking bistable perceptions in AI.",
            hiddenimage: "Hidden images with embedded shapes that AI might parse differently, leading to misdetections.",
            colorconstancy: "Color constancy illusions like 'the dress' fool color perception, affecting semantic segmentation.",
            animalpatch: "Animal-inspired patches (e.g., zebra/giraffe from Cap_able) make AI detect animals instead of humans.",
            psychedelic: "Psychedelic prints like adversarial glasses impersonate others or create blooming effects.",
            bloom: "Simulates IR LED bloom with high-contrast spots, confusing sensors with overexposure artifacts."
        };

        const patternTypes = {
            lines: (ctx, isColor, width, height, complexity) => {
                const numLines = Math.floor(50 + complexity * 150);
                for (let i = 0; i < numLines; i++) {
                    ctx.beginPath();
                    ctx.moveTo(seededRandom() * width, seededRandom() * height);
                    ctx.lineTo(seededRandom() * width, seededRandom() * height);
                    ctx.lineWidth = seededRandom() * 3 + 0.5;
                    ctx.strokeStyle = getColor(isColor);
                    ctx.stroke();
                }
            },
            circles: (ctx, isColor, width, height, complexity) => {
                const numCircles = Math.floor(20 + complexity * 80);
                for (let i = 0; i < numCircles; i++) {
                    const cx = seededRandom() * width;
                    const cy = seededRandom() * height;
                    const r = seededRandom() * 50 + 10;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.fillStyle = getColor(isColor);
                    ctx.strokeStyle = getColor(isColor);
                    ctx.fill();
                    ctx.lineWidth = seededRandom() * 2 + 0.5;
                    ctx.stroke();
                }
            },
            noise: (ctx, isColor, width, height, complexity) => {
                const imageData = ctx.createImageData(width, height);
                const intensity = complexity * 255;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const pert = (seededRandom() - 0.5) * intensity;
                    if (isColor) {
                        imageData.data[i] = (seededRandom() * 255 + pert) % 255;
                        imageData.data[i+1] = (seededRandom() * 255 + pert) % 255;
                        imageData.data[i+2] = (seededRandom() * 255 + pert) % 255;
                    } else {
                        const gray = (seededRandom() * 255 + pert) % 255;
                        imageData.data[i] = gray;
                        imageData.data[i+1] = gray;
                        imageData.data[i+2] = gray;
                    }
                    imageData.data[i+3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
            },
            grid: (ctx, isColor, width, height, complexity) => {
                const gridSize = Math.floor(10 + complexity * 20);
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const x = (i / (gridSize - 1) * width) + (seededRandom() * 10 - 5);
                        const y = (j / (gridSize - 1) * height) + (seededRandom() * 10 - 5);
                        ctx.beginPath();
                        ctx.arc(x, y, seededRandom() * 5 + 2, 0, 2 * Math.PI);
                        ctx.fillStyle = getColor(isColor);
                        ctx.fill();
                    }
                }
            },
            moire: (ctx, isColor, width, height, complexity) => {
                const cx = width / 2 + (seededRandom() * 100 - 50);
                const cy = height / 2 + (seededRandom() * 100 - 50);
                const step = 5 + (1 - complexity) * 10;
                for (let r = 10; r < Math.min(width, height) / 2; r += step) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = getColor(isColor);
                    ctx.stroke();
                }
            },
            dazzle: (ctx, isColor, width, height, complexity) => {
                const numBlocks = Math.floor(15 + complexity * 45);
                for (let i = 0; i < numBlocks; i++) {
                    const x = seededRandom() * width;
                    const y = seededRandom() * height;
                    const w = seededRandom() * 100 + 20;
                    const h = seededRandom() * 100 + 20;
                    const rotation = seededRandom() * Math.PI * 2;
                    ctx.save();
                    ctx.translate(x + w/2, y + h/2);
                    ctx.rotate(rotation);
                    ctx.translate(-(x + w/2), -(y + h/2));
                    ctx.fillStyle = seededRandom() > 0.5 ? '#000' : '#FFF';
                    ctx.fillRect(x, y, w, h);
                    ctx.restore();
                }
            },
            adversarial: (ctx, isColor, width, height, complexity) => {
                const imageData = ctx.createImageData(width, height);
                const pertScale = complexity * 50;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const perturbation = (Math.sin(i / 4) * pertScale) + (seededRandom() * pertScale * 2 - pertScale);
                    if (isColor) {
                        imageData.data[i] = (seededRandom() * 255 + perturbation) % 255;
                        imageData.data[i+1] = (seededRandom() * 255 + perturbation) % 255;
                        imageData.data[i+2] = (seededRandom() * 255 + perturbation) % 255;
                    } else {
                        const gray = (seededRandom() * 255 + perturbation) % 255;
                        imageData.data[i] = gray;
                        imageData.data[i+1] = gray;
                        imageData.data[i+2] = gray;
                    }
                    imageData.data[i+3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);
                ctx.globalAlpha = 0.2 + complexity * 0.3;
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(0, 0, width, height);
            },
            snake: (ctx, isColor, width, height, complexity) => {
                const size = Math.min(width, height);
                const num_rings = Math.floor(8 + complexity * 12);
                function linspace(start, end, num) {
                    const arr = [];
                    const step = (end - start) / (num - 1);
                    for (let i = 0; i < num; i++) {
                        arr.push(start + i * step);
                    }
                    return arr;
                }
                const r = linspace(0, size / 2, num_rings);
                const theta = linspace(0, 2 * Math.PI, size);
                const imgData = ctx.createImageData(size, size);
                const data = imgData.data;
                for (let i = 0; i < num_rings; i++) {
                    for (let j = 0; j < size; j++) {
                        const angle = theta[j];
                        const radius = r[i];
                        const x = Math.round((radius * Math.cos(angle)) + size / 2);
                        const y = Math.round((radius * Math.sin(angle)) + size / 2);
                        if (x >= 0 && x < size && y >= 0 && y < size) {
                            const idx = (y * size + x) * 4;
                            let color;
                            if (isColor) {
                                color = ((i + j) % 4 === 0) ? [255, 255, 0] : ((i + j) % 4 === 1) ? [0, 0, 255] : ((i + j) % 4 === 2) ? [0, 255, 0] : [255, 0, 0];
                            } else {
                                color = (i + j) % 2 === 0 ? [100, 100, 100] : [200, 200, 200];
                            }
                            data[idx] = color[0];
                            data[idx + 1] = color[1];
                            data[idx + 2] = color[2];
                            data[idx + 3] = 255;
                        }
                    }
                }
                ctx.putImageData(imgData, (width - size) / 2, (height - size) / 2);
            },
            invisibility: (ctx, isColor, width, height, complexity) => {
                const gridSize = Math.floor(15 + complexity * 35);
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const x = (i / (gridSize - 1) * width) + (seededRandom() * 15 - 7.5);
                        const y = (j / (gridSize - 1) * height) + (seededRandom() * 15 - 7.5);
                        const size = seededRandom() * 10 + 5;
                        ctx.beginPath();
                        ctx.rect(x, y, size, size);
                        const brightness = (seededRandom() - 0.5) * 100 * complexity;
                        if (isColor) {
                            let r = seededRandom()*255 + brightness;
                            let g = seededRandom()*255 + brightness;
                            let b = seededRandom()*255 + brightness;
                            ctx.fillStyle = `rgb(${(r % 255 + 255) % 255}, ${(g % 255 + 255) % 255}, ${(b % 255 + 255) % 255})`;
                        } else {
                            let gray = seededRandom() * 255 + brightness;
                            ctx.fillStyle = `rgb(${(gray % 255 + 255) % 255}, ${(gray % 255 + 255) % 255}, ${(gray % 255 + 255) % 255})`;
                        }
                        ctx.fill();
                    }
                }
            },
            penrose: (ctx, isColor, width, height, complexity) => {
                const scale = Math.min(width, height) / 400 * (0.5 + complexity * 0.5);
                ctx.save();
                ctx.translate(width / 2 - 200 * scale, height / 2 - 175 * scale);
                ctx.scale(scale, scale);
                ctx.lineJoin = 'round';
                ctx.lineWidth = 3 + complexity * 2;
                ctx.strokeStyle = getColor(isColor, 'highcontrast');
                const cubeColors = isColor ? ['#4f9bf7', '#c0d8fc', '#87b7ff'] : ['#ccc', '#aaa', '#ddd'];
                const cubeEdge = 30 + complexity * 20;
                const ch = cubeEdge * Math.sqrt(3) / 2;
                const chb = cubeEdge / 2;
                function drawCubeSide(x0, y0, x1, y1, x2, y2, x3, y3, color) {
                    ctx.beginPath();
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.stroke();
                    ctx.fill();
                }
                const numCubes = 3 + Math.floor(complexity * 2);
                for (let i = 0; i < numCubes; i++) {
                    const offset = i * 100;
                    drawCubeSide(offset, 300, offset + chb, 300 - ch, offset + cubeEdge, 300, offset + chb, 300 + ch, cubeColors[0]);
                    drawCubeSide(offset, 300, offset - cubeEdge, 300, offset - chb, 300 - ch, offset + chb, 300 - ch, cubeColors[1]);
                    drawCubeSide(offset, 300, offset + chb, 300 + ch, offset - chb, 300 + ch, offset - cubeEdge, 300, cubeColors[2]);
                }
                ctx.restore();
            },
            zebra: (ctx, isColor, width, height, complexity) => {
                const stripeWidth = (10 + (1 - complexity) * 20);
                const numStripes = Math.ceil(height / (stripeWidth * 2));
                for (let y = 0; y < height; y += stripeWidth * 2) {
                    ctx.fillStyle = seededRandom() > 0.5 ? '#000' : '#FFF';
                    ctx.fillRect(0, y, width, stripeWidth);
                    ctx.fillStyle = getColor(isColor);
                    ctx.fillRect(0, y + stripeWidth, width, stripeWidth);
                }
            },
            muller: (ctx, isColor, width, height, complexity) => {
                const cols = Math.floor(10 + complexity * 10);
                const rows = Math.floor(3 + complexity * 3);
                const gap = width / (cols + 1);
                const l = (height - 2 * gap) / rows;
                ctx.translate(gap, gap);
                ctx.lineWidth = 2 + complexity;
                for (let x = 0; x < cols; x++) {
                    const y_off = Math.cos(3 * Math.PI * x / cols) * gap / 2 * (1 + complexity);
                    for (let y = 0; y < rows + 1; y++) {
                        ctx.strokeStyle = getColor(isColor);
                        if (y < rows) {
                            ctx.beginPath();
                            ctx.moveTo(x * gap, y * l);
                            ctx.lineTo(x * gap, y * l + l);
                            ctx.stroke();
                        }
                        ctx.strokeStyle = getColor(isColor, 'highcontrast');
                        const y_off_flipped = y_off * -1;
                        ctx.beginPath();
                        ctx.moveTo(x * gap, y * l);
                        ctx.lineTo(x * gap - gap / 2, y * l - y_off_flipped);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x * gap, y * l);
                        ctx.lineTo(x * gap + gap / 2, y * l - y_off_flipped);
                        ctx.stroke();
                    }
                }
            },
            checker: (ctx, isColor, width, height, complexity) => {
                const squareSize = 30 + (1 - complexity) * 40;
                for (let y = 0; y < height; y += squareSize) {
                    for (let x = 0; x < width; x += squareSize) {
                        const gray = ((x / squareSize + y / squareSize) % 2 === 0) ? 150 : 100;
                        ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
                ctx.fillStyle = `rgba(0,0,0,${0.2 + complexity * 0.4})`;
                ctx.fillRect(squareSize * 2, squareSize, width - squareSize * 4, height - squareSize * 2);
                ctx.fillStyle = getColor(isColor);
                ctx.beginPath();
                ctx.ellipse(width / 2, height - 20, 100 + complexity * 50, 20 + complexity * 10, 0, 0, 2 * Math.PI);
                ctx.fill();
            },
            stairs: (ctx, isColor, width, height, complexity) => {
                ctx.clearRect(0, 0, width, height);
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas: ctx.canvas, antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;

                const light = new THREE.DirectionalLight(0xffffff, 1 + complexity);
                light.position.set(5, 10, 5);
                light.castShadow = true;
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x404040));

                const stepSize = { x: 200, y: 20 + complexity * 10, z: 100 };
                const stepsAmount = 4 + Math.floor(complexity * 4);
                for (let i = 0; i < stepsAmount; i++) {
                    const stepGeometry = new THREE.BoxGeometry(stepSize.x, stepSize.y, stepSize.z);
                    const stepMaterial = new THREE.MeshStandardMaterial({ color: getThreeColor(isColor) });
                    const step = new THREE.Mesh(stepGeometry, stepMaterial);
                    step.receiveShadow = true;

                    const spikeGeometry = new THREE.ConeGeometry(15 + complexity * 10, 50 + complexity * 20, 32);
                    const spikeMaterial = new THREE.MeshStandardMaterial({ color: getThreeColor(isColor, 'psychedelic') });
                    const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                    spike.position.set(seededRandom() * 100 - 50, stepSize.y / 2 + 25, 0);
                    spike.castShadow = true;

                    const group = new THREE.Group();
                    group.add(step);
                    group.add(spike);
                    group.position.set(0, i * stepSize.y, i * -stepSize.z / 2);
                    group.rotation.y = seededRandom() * Math.PI / 4;
                    scene.add(group);
                }

                camera.position.set(0, 100 + complexity * 50, 300);
                camera.lookAt(0, 0, 0);
                renderer.render(scene, camera);
            },
            fraser: (ctx, isColor, width, height, complexity) => {
                const squareSize = 15 + (1 - complexity) * 15;
                for (let y = 0; y < height; y += squareSize) {
                    for (let x = 0; x < width; x += squareSize) {
                        ctx.fillStyle = ((x / squareSize + y / squareSize) % 2 === 0) ? getColor(isColor, 'highcontrast') : getColor(isColor, 'subtle');
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.rotate(Math.PI / 180 * (3 + complexity * 7));
                ctx.translate(-width / 2, -height / 2);
                const cx = width / 2;
                const cy = height / 2;
                const numRings = Math.floor(10 + complexity * 20);
                for (let r = 10; r < Math.min(width, height) / 2; r += 10) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                    ctx.lineWidth = 2 + complexity;
                    ctx.strokeStyle = getColor(isColor);
                    ctx.stroke();
                }
                ctx.restore();
            },
            mandelbrot: (ctx, isColor, width, height, complexity) => {
                const maxIterations = Math.floor(50 + complexity * 150);
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                const xmin = -2.5, xmax = 1, ymin = -1, ymax = 1;
                for (let py = 0; py < height; py++) {
                    const y0 = ymin + (ymax - ymin) * py / height;
                    for (let px = 0; px < width; px++) {
                        const x0 = xmin + (xmax - xmin) * px / width;
                        let x = 0, y = 0;
                        let iteration = 0;
                        while (x * x + y * y <= 4 && iteration < maxIterations) {
                            const xtemp = x * x - y * y + x0;
                            y = 2 * x * y + y0;
                            x = xtemp;
                            iteration++;
                        }
                        const index = (py * width + px) * 4;
                        let color;
                        if (iteration === maxIterations) {
                            color = [0, 0, 0];
                        } else {
                            const hue = (iteration / maxIterations) * 360;
                            color = isColor ? hsvToRgb(hue, 1, 1) : [iteration * 255 / maxIterations, iteration * 255 / maxIterations, iteration * 255 / maxIterations];
                        }
                        data[index] = color[0];
                        data[index + 1] = color[1];
                        data[index + 2] = color[2];
                        data[index + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            julia: (ctx, isColor, width, height, complexity) => {
                const maxIterations = Math.floor(50 + complexity * 150);
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;
                const cx = -0.7 + seededRandom() * 0.2 * complexity;
                const cy = 0.27015 + seededRandom() * 0.1 * complexity;
                const xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5;
                for (let py = 0; py < height; py++) {
                    let y = ymin + (ymax - ymin) * py / height;
                    for (let px = 0; px < width; px++) {
                        let x = xmin + (xmax - xmin) * px / width;
                        let iteration = 0;
                        while (x * x + y * y <= 4 && iteration < maxIterations) {
                            const xtemp = x * x - y * y + cx;
                            y = 2 * x * y + cy;
                            x = xtemp;
                            iteration++;
                        }
                        const index = (py * width + px) * 4;
                        let color;
                        if (iteration === maxIterations) {
                            color = [0, 0, 0];
                        } else {
                            const hue = (iteration / maxIterations) * 360;
                            color = isColor ? hsvToRgb(hue, 1, 1) : [iteration * 255 / maxIterations, iteration * 255 / maxIterations, iteration * 255 / maxIterations];
                        }
                        data[index] = color[0];
                        data[index + 1] = color[1];
                        data[index + 2] = color[2];
                        data[index + 3] = 255;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            },
            sierpinski: (ctx, isColor, width, height, complexity) => {
                const levels = Math.floor(5 + complexity * 5);
                function drawTriangle(x1, y1, x2, y2, x3, y3) {
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                    ctx.fillStyle = getColor(isColor);
                    ctx.fill();
                }
                function sierpinski(x1, y1, x2, y2, x3, y3, level) {
                    if (level === 0) {
                        drawTriangle(x1, y1, x2, y2, x3, y3);
                    } else {
                        const mx1 = (x1 + x2) / 2;
                        const my1 = (y1 + y2) / 2;
                        const mx2 = (x2 + x3) / 2;
                        const my2 = (y2 + y3) / 2;
                        const mx3 = (x3 + x1) / 2;
                        const my3 = (y3 + y1) / 2;
                        sierpinski(x1, y1, mx1, my1, mx3, my3, level - 1);
                        sierpinski(mx1, my1, x2, y2, mx2, my2, level - 1);
                        sierpinski(mx3, my3, mx2, my2, x3, y3, level - 1);
                    }
                }
                const side = Math.min(width, height);
                const h = side * Math.sqrt(3) / 2;
                sierpinski(width / 2 - side / 2, height / 2 - h / 2, width / 2 + side / 2, height / 2 - h / 2, width / 2, height / 2 + h / 2, levels);
            },
            koch: (ctx, isColor, width, height, complexity) => {
                const levels = Math.floor(3 + complexity * 4);
                function koch(x1, y1, x2, y2, level) {
                    if (level === 0) {
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = getColor(isColor);
                        ctx.stroke();
                    } else {
                        const dx = x2 - x1;
                        const dy = y2 - y1;
                        const x3 = x1 + dx / 3;
                        const y3 = y1 + dy / 3;
                        const x4 = x1 + dx / 2 + dy / 3 * Math.sqrt(3) / 2 * (seededRandom() > 0.5 ? 1 : -1);
                        const y4 = y1 + dy / 2 - dx / 3 * Math.sqrt(3) / 2 * (seededRandom() > 0.5 ? 1 : -1);
                        const x5 = x1 + 2 * dx / 3;
                        const y5 = y1 + 2 * dy / 3;
                        koch(x1, y1, x3, y3, level - 1);
                        koch(x3, y3, x4, y4, level - 1);
                        koch(x4, y4, x5, y5, level - 1);
                        koch(x5, y5, x2, y2, level - 1);
                    }
                }
                const side = Math.min(width, height) * 0.8;
                const h = side * Math.sqrt(3) / 2;
                koch(width / 2 - side / 2, height / 2 - h / 3, width / 2 + side / 2, height / 2 - h / 3, levels);
                koch(width / 2 + side / 2, height / 2 - h / 3, width / 2, height / 2 + 2 * h / 3, levels);
                koch(width / 2, height / 2 + 2 * h / 3, width / 2 - side / 2, height / 2 - h / 3, levels);
            },
            duckrabbit: (ctx, isColor, width, height, complexity) => {
                // Simplified duck-rabbit drawing
                const scale = Math.min(width, height) / 200 * (0.5 + complexity * 0.5);
                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.scale(scale, scale);
                ctx.lineWidth = 5 + complexity * 5;
                ctx.strokeStyle = getColor(isColor, 'highcontrast');
                // Ears/beak
                ctx.beginPath();
                ctx.moveTo(-50, -20);
                ctx.lineTo(-80, -40);
                ctx.lineTo(-100, -20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-50, -20);
                ctx.lineTo(-80, 0);
                ctx.lineTo(-100, -20);
                ctx.stroke();
                // Head
                ctx.beginPath();
                ctx.arc(0, 0, 50, 0, Math.PI * 2);
                ctx.stroke();
                // Eye
                ctx.beginPath();
                ctx.arc(-20, -10, 5, 0, Math.PI * 2);
                ctx.fillStyle = getColor(isColor);
                ctx.fill();
                ctx.restore();
            },
            hiddenimage: (ctx, isColor, width, height, complexity) => {
                // Random shapes with hidden circle or square
                const numShapes = Math.floor(50 + complexity * 100);
                for (let i = 0; i < numShapes; i++) {
                    ctx.beginPath();
                    ctx.rect(seededRandom() * width, seededRandom() * height, 20 + seededRandom() * 30, 20 + seededRandom() * 30);
                    ctx.fillStyle = getColor(isColor, 'subtle');
                    ctx.fill();
                }
                // Hidden circle
                ctx.globalAlpha = 0.3 + complexity * 0.4;
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, 100 + complexity * 50, 0, 2 * Math.PI);
                ctx.fillStyle = getColor(isColor);
                ctx.fill();
                ctx.globalAlpha = 1;
            },
            colorconstancy: (ctx, isColor, width, height, complexity) => {
                // Blue filter over pink-like colors
                ctx.fillStyle = '#FFC0CB'; // Pink
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 0.5 + complexity * 0.3;
                ctx.fillStyle = '#0000FF'; // Blue filter
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1;
                // Add stripes or patterns
                const stripeWidth = 20 + (1 - complexity) * 30;
                for (let x = 0; x < width; x += stripeWidth * 2) {
                    ctx.fillStyle = getColor(isColor, 'earthtones');
                    ctx.fillRect(x, 0, stripeWidth, height);
                }
            },
            animalpatch: (ctx, isColor, width, height, complexity) => {
                // Patch that looks like animal stripes/spots
                const numSpots = Math.floor(20 + complexity * 80);
                for (let i = 0; i < numSpots; i++) {
                    const cx = seededRandom() * width;
                    const cy = seededRandom() * height;
                    const r = 20 + seededRandom() * 40;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, r, r / 2, seededRandom() * Math.PI, 0, 2 * Math.PI);
                    ctx.fillStyle = getColor(isColor, 'earthtones');
                    ctx.fill();
                }
            },
            psychedelic: (ctx, isColor, width, height, complexity) => {
                const numSwirls = Math.floor(10 + complexity * 40);
                for (let i = 0; i < numSwirls; i++) {
                    const cx = seededRandom() * width;
                    const cy = seededRandom() * height;
                    for (let r = 5; r < 50 + complexity * 50; r += 5) {
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                        ctx.strokeStyle = getColor(isColor, 'psychedelic');
                        ctx.lineWidth = 2 + complexity;
                        ctx.stroke();
                    }
                }
            },
            bloom: (ctx, isColor, width, height, complexity) => {
                const numBlooms = Math.floor(20 + complexity * 80);
                for (let i = 0; i < numBlooms; i++) {
                    const cx = seededRandom() * width;
                    const cy = seededRandom() * height;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50 + complexity * 50);
                    gradient.addColorStop(0, '#FFF');
                    gradient.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 50 + complexity * 50, 0, 2 * Math.PI);
                    ctx.fill();
                }
                if (!isColor) {
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = '#888';
                    ctx.fillRect(0, 0, width, height);
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
        };

        let currentPalette = 'random';
        function getColor(isColor, palette = currentPalette) {
            if (!isColor) {
                const gray = seededRandom() * 255;
                return `rgb(${gray}, ${gray}, ${gray})`;
            }
            switch (palette) {
                case 'highcontrast':
                    return seededRandom() > 0.5 ? '#000' : '#FFF';
                case 'subtle':
                    const subtle = 128 + (seededRandom() - 0.5) * 50;
                    return `rgb(${subtle}, ${subtle}, ${subtle})`;
                case 'earthtones':
                    return `rgb(${100 + seededRandom() * 100}, ${50 + seededRandom() * 100}, ${0 + seededRandom() * 50})`;
                case 'psychedelic':
                    return `hsl(${seededRandom() * 360}, 100%, 50%)`;
                case 'irsim':
                    return `rgb(${seededRandom() * 255}, ${seededRandom() * 255}, ${seededRandom() * 255})`; // But grayscale for BW
                default:
                    return `rgb(${seededRandom()*255}, ${seededRandom()*255}, ${seededRandom()*255})`;
            }
        }

        function getThreeColor(isColor, palette = currentPalette) {
            const colorStr = getColor(isColor, palette);
            const rgb = colorStr.match(/\d+/g).map(Number);
            return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h / 60);
            const f = h / 60 - i;
            const p = v * (1 - s);
            const q = v * (1 - s * f);
            const t = v * (1 - s * (1 - f));
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function drawPattern(ctx, isColor, width, height, selectedType, complexity, combine, numLayers, opacity, composite) {
            ctx.clearRect(0, 0, width, height);
            let typesToDraw = [];
            if (selectedType === 'random') {
                const keys = Object.keys(patternTypes);
                typesToDraw.push(keys[Math.floor(seededRandom() * keys.length)]);
            } else {
                typesToDraw.push(selectedType);
            }
            if (combine) {
                const keys = Object.keys(patternTypes);
                for (let i = 1; i < numLayers; i++) {  // Start from 1 to include primary
                    typesToDraw.push(keys[Math.floor(seededRandom() * keys.length)]);
                }
            }
            typesToDraw.forEach((type, index) => {
                try {
                    ctx.save();
                    ctx.globalAlpha = opacity * (1 - index / typesToDraw.length * 0.5); // Gradual opacity
                    ctx.globalCompositeOperation = composite;
                    patternTypes[type](ctx, isColor, width, height, complexity);
                    ctx.restore();
                } catch (e) {
                    console.error(`Error drawing ${type}: ${e}`);
                }
            });
            return typesToDraw; // Return for info
        }

        function tilePattern(ctx, width, height, tileCount, drawFunc) {
            const tileW = width / tileCount;
            const tileH = height / tileCount;
            for (let tx = 0; tx < tileCount; tx++) {
                for (let ty = 0; ty < tileCount; ty++) {
                    ctx.save();
                    ctx.translate(tx * tileW, ty * tileH);
                    drawFunc(ctx, tileW, tileH);
                    ctx.restore();
                }
            }
        }

        function generatePatterns() {
            const colorCanvas = document.getElementById('colorCanvas');
            const bwCanvas = document.getElementById('bwCanvas');
            let w = parseInt(document.getElementById('canvasWidth').value);
            let h = parseInt(document.getElementById('canvasHeight').value);
            colorCanvas.width = w;
            colorCanvas.height = h;
            bwCanvas.width = w;
            bwCanvas.height = h;
            const colorCtx = colorCanvas.getContext('2d');
            const bwCtx = bwCanvas.getContext('2d');
            const selectedType = document.getElementById('patternSelect').value;
            const combine = document.getElementById('combineCheckbox').checked;
            const numLayers = parseInt(document.getElementById('numLayers').value);
            const opacity = parseFloat(document.getElementById('opacitySlider').value);
            const composite = document.getElementById('compositeMode').value;
            const complexity = parseFloat(document.getElementById('complexitySlider').value);
            currentPalette = document.getElementById('colorPalette').value;
            seed = parseInt(document.getElementById('seedInput').value) || Math.floor(Math.random() * 1000000);
            const tileCount = document.getElementById('tileCheckbox').checked ? parseInt(document.getElementById('tileCount').value) : 1;

            const colorDrawFunc = (subCtx, subW, subH) => {
                drawPattern(subCtx, true, subW, subH, selectedType, complexity, combine, numLayers, opacity, composite);
            };
            const bwDrawFunc = (subCtx, subW, subH) => {
                drawPattern(subCtx, false, subW, subH, selectedType, complexity, combine, numLayers, opacity, composite);
            };

            if (tileCount > 1) {
                tilePattern(colorCtx, w, h, tileCount, colorDrawFunc);
                tilePattern(bwCtx, w, h, tileCount, bwDrawFunc);
            } else {
                colorDrawFunc(colorCtx, w, h);
                bwDrawFunc(bwCtx, w, h);
            }
        }

        function exportPNG(canvasId) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `\( {canvasId}_ \){new Date().toISOString()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function exportSVG(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="\( {canvas.width}" height=" \){canvas.height}">`;
            // Simple pixel-to-rect conversion for SVG (may be slow for large canvases)
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const i = (y * canvas.width + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i+1];
                    const b = imageData.data[i+2];
                    const a = imageData.data[i+3] / 255;
                    if (a > 0) {
                        svg += `<rect x="\( {x}" y=" \){y}" width="1" height="1" fill="rgba(\( {r}, \){g},\( {b}, \){a})" />`;
                    }
                }
            }
            svg += '</svg>';
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `\( {canvasId}_ \){new Date().toISOString()}.svg`;
            link.href = url;
            link.click();
        }

        function showInfo() {
            const infoPanel = document.getElementById('infoPanel');
            const desc = document.getElementById('patternDescription');
            const selectedType = document.getElementById('patternSelect').value;
            desc.textContent = patternDescriptions[selectedType] || 'No description available.';
            infoPanel.style.display = 'block';
        }

        // Initial generation
        generatePatterns();
    </script>
</body>
</html>
